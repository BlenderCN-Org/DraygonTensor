#pragma once

#include <string>

#include "engine/resource/ResourceFactory.h"
#include "engine/system/ISystem.h"
#include "engine/system/render/IRenderer.h"
#include "engine/system/render/Material.h"
#include "engine/system/render/Mesh.h"
#include "engine/system/render/RenderComponentManager.h"
#include "engine/system/render/Texture.h"
#include "engine/system/scene/TransformComponentManager.h"

#include "math/Vector3.h"

namespace ds
{
/**
 * The render system is responsible for rendering the world, it contains all
 * render specific data, including the render component data for each entity.
 */
class Render : public ISystem
{
public:
    /**
     * Initialize the render system.
     *
     * Returns FALSE if initialization fails.
     *
     * @param   config  const Config &, configuration loaded by engine.
     * @return          bool, TRUE if initialization succeeds, FALSE otherwise.
     */
    virtual bool Initialize(const Config &config);

    /**
     * Update the render system over the given timestep.
     *
     * @param  deltaTime  float, timestep to update the system over.
     */
    virtual void Update(float deltaTime);

    /**
     * Perform teardown of the render system.
     */
    virtual void Shutdown();

    /**
     * Give messages to the render system.
     *
     * Messages are not handled in this method. Handling of events is deferred
     * to the Update method.
     *
     * @param  messages  const ds_msg::MessageStream &messages, messages to send
     * to the Message Bus.
     */
    virtual void PostMessages(const ds_msg::MessageStream &messages);

    /**
     * Collect messages generated by the render system.
     *
     * @return  ds_msg::MessageStream, stream of messages generated by this
     * system.
     */
    virtual ds_msg::MessageStream CollectMessages();

private:
    /**
     * Process messages in the given message stream.
     *
     * @param  ds_msg::MessageStream *, messages to process.
     */
    void ProcessEvents(ds_msg::MessageStream *messages);

    /**
     * Create a Texture object from a path to a texture resource.
     *
     * @param   filePath  const std::string &, path to texture resource.
     * @return            ds_render::Texture, texture created.
     */
    ds_render::Texture
    CreateTextureFromTextureResource(const std::string &filePath);

    /**
     * Create a Mesh object from a path to a mesh resource.
     *
     * @param   filePath  const std::string &, path to mesh resource.
     * @return            ds_render::Mesh, mesh created.
     */
    ds_render::Mesh CreateMeshFromMeshResource(const std::string &filePath);

    /**
     * Create a Material object from a path to a material resource.
     *
     * Will attempt to bind Scene and Object constant buffers by default.
     *
     * @param   filePath        const std::string &, path to material resource.
     * @param   sceneMatrices   ds_render::ConstantBufferHandle, handle to
     * constant buffer containing scene matrix data.
     * @param   objectMatrices  ds_render::ConstantBufferHandle, handle to
     * constant buffer containing object matrix data.
     * @return                  ds_render::Material, material created.
     */
    // ds_render::Material
    // CreateMaterialFromMaterialResource(const std::string &filePath);
    ds_render::Material CreateMaterialFromMaterialResource(
        const std::string &filePath,
        ds_render::ConstantBufferHandle sceneMatrices,
        ds_render::ConstantBufferHandle objectMatrices);

    /**
     * Create a render component for the given entity using the given component
     * data string.
     *
     * @param  entity         Entity, entity to create render component for.
     * @param  componentData  const std::string &, component data string to
     * create render component from.
     */
    // void CreateRenderComponentFor(Entity entity,
    //                               const std::string &componentData);

    /**
     * Render the scene.
     */
    void RenderScene();

    /** Messages generated and received by this system */
    ds_msg::MessageStream m_messagesGenerated, m_messagesReceived;

    ResourceFactory m_factory;

    /** Renderer */
    std::unique_ptr<ds_render::IRenderer> m_renderer;

    /** Render component manager */
    ds_render::RenderComponentManager m_renderComponentManager;
    /** Transform component manager */
    TransformComponentManager m_transformComponentManager;

    ds_render::Mesh m_mesh;
    ds_render::Material m_material;
    ds_render::ProgramHandle m_program;

    ds_render::ConstantBufferHandle m_sceneMatrices;
    ds_render::ConstantBufferHandle m_objectMatrices;
    ds_render::ConstantBufferDescription m_sceneBufferDescrip;
    ds_render::ConstantBufferDescription m_objectBufferDescrip;

    ds_math::Matrix4 m_viewMatrix;
    ds_math::Matrix4 m_projectionMatrix;
};
// bool result = true;

// // Register creators
// m_factory.RegisterCreator<MaterialResource>(
//     MaterialResource::CreateFromFile);
// m_factory.RegisterCreator<MeshResource>(MeshResource::CreateFromFile);
// m_factory.RegisterCreator<ShaderResource>(ShaderResource::CreateFromFile);
// m_factory.RegisterCreator<TextureResource>(TextureResource::CreateFromFile);

// m_renderer =
//     std::unique_ptr<ds_render::IRenderer>(new ds_render::GLRenderer());

// // TODO: Handle resize messages to change this
// unsigned int viewportWidth = 800;
// unsigned int viewportHeight = 600;

// m_renderer->Init(viewportWidth, viewportHeight);

// // Need a program to get information about Scene and Object constant
// // buffers, so create a "fake" one.
// // Create shader program
// std::unique_ptr<ShaderResource> shaderResource =
//     m_factory.CreateResource<ShaderResource>(
//         "../assets/constantBuffer.shader");

// // Load each shader
// std::vector<ds_render::ShaderHandle> shaders;
// std::vector<ds_render::ShaderType> shaderTypes =
//     shaderResource->GetShaderTypes();
// for (auto shaderType : shaderTypes)
// {
//     const std::string &shaderSource =
//         shaderResource->GetShaderSource(shaderType);

//     // Append shader to list
//     shaders.push_back(m_renderer->CreateShaderObject(
//         shaderType, shaderSource.size(), shaderSource.c_str()));
//     std::cout << shaderSource << std::endl;
// }
// // Compile shaders into shader program
// ds_render::ProgramHandle shaderProgram = m_renderer->CreateProgram(shaders);
// m_program = shaderProgram;

// // Get shader data descriptions
// m_sceneBufferDescrip.AddMember("Scene.viewMatrix");
// m_sceneBufferDescrip.AddMember("Scene.projectionMatrix");
// m_renderer->GetConstantBufferDescription(shaderProgram, "Scene",
//                                          &m_sceneBufferDescrip);

// m_objectBufferDescrip.AddMember("Object.modelMatrix");
// m_renderer->GetConstantBufferDescription(shaderProgram, "Object",
//                                          &m_objectBufferDescrip);


// // Create shader data
// m_viewMatrix = ds_math::Matrix4(1.0f);
//     // ds_math::Matrix4::CreateTranslationMatrix(-0.0f, -0.0f, -4.0f);
// m_projectionMatrix = ds_math::Matrix4::CreatePerspectiveFieldOfView(
//     ds_math::MathHelper::PI / 3.0f, 800.0f / 600.0f, 0.1f, 100.0f);
// m_sceneBufferDescrip.InsertMemberData(
//     "Scene.viewMatrix", sizeof(ds_math::Matrix4), &m_viewMatrix);
// m_sceneBufferDescrip.InsertMemberData("Scene.projectionMatrix",
//                                       sizeof(ds_math::Matrix4),
//                                       &m_projectionMatrix);

// ds_math::Matrix4 modelMatrix = // ds_math::Matrix4(1.0f);
//     ds_math::Matrix4::CreateTranslationMatrix(-4.0f, -3.0f, -10.0f);
// m_objectBufferDescrip.InsertMemberData(
//     "Object.modelMatrix", sizeof(ds_math::Matrix4), &modelMatrix);

// m_sceneMatrices = m_renderer->CreateConstantBuffer(m_sceneBufferDescrip);
// m_objectMatrices = m_renderer->CreateConstantBuffer(m_objectBufferDescrip);

// // Create Mesh
// m_mesh = CreateMeshFromMeshResource("../assets/cube.obj");

// // Create material
// m_material = CreateMaterialFromMaterialResource("../assets/test.material");

// Entity testEntity;
// testEntity.id = 0;
// Instance i = m_renderComponentManager.CreateComponentForEntity(testEntity);
// m_renderComponentManager.SetMaterial(i, m_material);
// m_renderComponentManager.SetMesh(i, m_mesh);

// // Bind scene and object
// m_renderer->BindConstantBuffer(m_material.GetProgram(), "Scene",
// m_sceneMatrices);
// m_renderer->BindConstantBuffer(m_material.GetProgram(), "Object",
// m_objectMatrices);


// return result;
}
