* Special Features

- Mention CMake cross-platform build
- Lua script components and parameters
- Blender export stuff
- Data files, data-driven development

** Cross-platform build system 

At the beginning of the semester, it was determined that members of the
development team would like to develop on different platforms (Windows, OSX and
Linux). So it was important that we create a build system that allows each
member of the team to contribute to the project on their platform. We used CMake
for this purpose. CMake allows us to create one set of project files from which
Visual Studio, XCode and Makefile project files can be created.

These CMake project files have the name "CMakeLists.txt" and are responsible for
finding all dependecies for the project.

** Data-driven design

** Blender plugin 

Because the engine is almost completely data-driven, we were able to write some
external tools to more easily produce the data we needed for our game. One of
the tools we used was Blender.

Blender exposes much of it's functionality via a Python scripting interface, we
developed a number of Python modules to add some additional functionality to
Blender.

*** The export script

We wrote a script that takes an entire scene in Blender and outputs it in a
format our game engine expects. A .prefab file is created for each object in the
scene and a .lua file is created which spawns each of these .prefab files. Also,
.material, .texture and .mesh files are outputted and any assets needed to run
the game are exported from Blender to the export location.

#+NAME: src/blender/addons/io_draygon/__init__.py 
#+BEGIN_SRC python
...
def writeAll(context, folderpath, levelpath):

    # Open lua level file
    levelout = open(levelpath, 'w')
    levelname = os.path.splitext(os.path.split(levelpath)[1])[0]
    # Create level loading file
    levelout.write("function " + levelname + "(offset)\n")

    # For each object in the scene
    scene = bpy.context.scene
    for obj in scene.objects:
        if (obj.type == 'MESH'):
            ...
            # Output necessary data files 
            reltexturepath = writeObjectTexture(obj, folderpath)
            relmaterialpath = writeObjectMaterial(obj, folderpath, reltexturepath)
            relmeshpath = writeObjectMesh(obj, folderpath)
            relprefabpath = writePrefab(obj, folderpath, relmeshpath, relmaterialpath)

            # Ensure the object is spawned in the correct place 
            position = "Vector3(" + str(obj.location.x) + ", " + str(obj.location.z) + ", " + str(-obj.location.y) + ")"
            scale = "Vector3(" + str(obj.scale.x) + ", " + str(obj.scale.z) + ", " + str(obj.scale.y) + ")"
            orientation = obj.rotation_euler.to_quaternion()

            orientation = "Quaternion(" + str(orientation[1]) + ", " + str(orientation[3]) + ", " + str(-orientation[2]) + ", " + str(orientation[0]) + ")"

            levelout.write(luatab + "local location = " + position + "\n")
            levelout.write(luatab + "if offset ~= nil then\n")
            levelout.write(luatab + luatab + "location = location + offset\n")
            levelout.write(luatab + "end\n")
            levelout.write(luatab + "Script.spawn_prefab(\"" + os.path.splitext(relprefabpath)[0] + "\", location" + ", " + orientation + ", " + scale + ")\n")

    # Finish level file
    levelout.write("end")
    levelout.close()

    return {'FINISHED'}
...
#+END_SRC

All the user has to do to spawn all these prefabs in the world is include the
created .lua file in their boot script and call the appropriate method. For
example:

#+NAME: boot.lua
#+BEGIN_SRC lua 
require 'GymProgressBackUp8'

function preinit()
    ...
    GymProgressBackUp8()
    ...
end
#+END_SRC

Will spawn the entire gym scene in the game.

*** The affordance plugin

Affordances (for those objects that have them) are also exported using the
Blender export script. However, Blender does not natively have any concept of
affordances for objects. We added this ability to Blender using the Python
scripting API.

We created a field that allows users to add affordances and their value for each
object in the world. This is pictured below:

~PIC~

These values were then included in the export script.

*** The rigid body plugin 

Blender does have the concept of rigid bodies natively, but not necessarily for
multiple collisions shapes per rigid body, each with their own mass and inertia
tensors. We also needed to add this concept to Blender ourselves.

The result is pictured below:

~PIC~

These values were then included in the export script.
